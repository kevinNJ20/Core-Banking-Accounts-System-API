<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns="http://www.mulesoft.org/schema/mule/core"
  xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
  xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns:db="http://www.mulesoft.org/schema/mule/db"
      xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
      http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
	http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
	http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd">

  <!-- GET /accounts - Business Logic Flow -->
  <flow name="get-accounts-business-logic" doc:name="get-accounts-business-logic">
    <try doc:name="Try">
      <ee:transform doc:name="Build Query Parameters">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/java
var params = payload default {}
---
{
  customerId: if (params.customerId != null and params.customerId != "") params.customerId else null,
  accountNumber: if (params.accountNumber != null and params.accountNumber != "") params.accountNumber else null,
  accountType: if (params.accountType != null and params.accountType != "") params.accountType else null,
  status: if (params.status != null and params.status != "") params.status else null,
  limit: params.limit as Number default 100,
  offset: params.offset as Number default 0
}]]></ee:set-payload>
        </ee:message>
        <ee:variables>
          <ee:set-variable variableName="queryParams"><![CDATA[%dw 2.0
output application/java
---
payload]]></ee:set-variable>
        </ee:variables>
      </ee:transform>
      
      <choice doc:name="Has Customer ID Filter?">
        <when expression="#[vars.queryParams.customerId != null]">
          <db:select config-ref="Database_Config" doc:name="Select Accounts with Customer Filter">
            <db:sql><![CDATA[
              SELECT DISTINCT a.*
              FROM accounts a
              INNER JOIN account_owners ao ON a.id = ao.account_id
              WHERE ao.customer_id = :customerId::uuid
                AND (COALESCE(:accountNumber, '') = '' OR a.account_number = :accountNumber)
                AND (COALESCE(:accountType, '') = '' OR a.account_type = :accountType)
                AND (COALESCE(:status, '') = '' OR a.status = :status)
              ORDER BY a.created_at DESC
              LIMIT :limit OFFSET :offset
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[%dw 2.0
output application/java
var params = vars.queryParams
---
{
  customerId: params.customerId,
  accountNumber: params.accountNumber default "",
  accountType: params.accountType default "",
  status: params.status default "",
  limit: params.limit,
  offset: params.offset
}]]]></db:input-parameters>
          </db:select>
        </when>
        <otherwise>
          <db:select config-ref="Database_Config" doc:name="Select Accounts without Customer Filter">
            <db:sql><![CDATA[
              SELECT DISTINCT a.*
              FROM accounts a
              WHERE
                (COALESCE(:accountNumber, '') = '' OR a.account_number = :accountNumber)
                AND (COALESCE(:accountType, '') = '' OR a.account_type = :accountType)
                AND (COALESCE(:status, '') = '' OR a.status = :status)
              ORDER BY a.created_at DESC
              LIMIT :limit OFFSET :offset
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[%dw 2.0
output application/java
var params = vars.queryParams
---
{
  accountNumber: params.accountNumber default "",
  accountType: params.accountType default "",
  status: params.status default "",
  limit: params.limit,
  offset: params.offset
}]]]></db:input-parameters>
          </db:select>
        </otherwise>
      </choice>

      <ee:transform doc:name="Store Accounts">
        <ee:variables>
          <ee:set-variable variableName="accounts"><![CDATA[%dw 2.0
output application/java
---
if (payload is Array) payload else [payload] default []]]></ee:set-variable>
        </ee:variables>
      </ee:transform>

      <choice doc:name="Has Accounts?">
        <when expression="#[sizeOf(vars.accounts) > 0]">
          <ee:transform doc:name="Build Account IDs List">
            <ee:variables>
              <ee:set-variable variableName="accountIdsList"><![CDATA[%dw 2.0
output application/java
---
vars.accounts map ((acc) -> acc.id)]]></ee:set-variable>
            </ee:variables>
          </ee:transform>
          
          <choice doc:name="Has Account IDs?">
            <when expression="#[sizeOf(vars.accountIdsList) > 0]">
              <foreach collection="#[vars.accountIdsList]" doc:name="For Each Account ID">
                <db:select config-ref="Database_Config" doc:name="Select Account Owners">
                  <db:sql><![CDATA[
                    SELECT account_id, customer_id, relationship_type
                    FROM account_owners
                    WHERE account_id = :accountId::uuid
                  ]]></db:sql>
                  <db:input-parameters><![CDATA[#[{
                    accountId: payload
                  }]]]></db:input-parameters>
                </db:select>
                <ee:transform doc:name="Collect Owners">
                  <ee:variables>
                    <ee:set-variable variableName="owners"><![CDATA[%dw 2.0
output application/java
---
if (vars.owners == null) payload else vars.owners ++ payload]]></ee:set-variable>
                  </ee:variables>
                </ee:transform>
              </foreach>
              <set-payload value="#[vars.owners default []]" doc:name="Set Owners Payload"/>
            </when>
            <otherwise>
              <set-payload value="#[[]]" doc:name="Set Empty Array"/>
            </otherwise>
          </choice>
        </when>
        <otherwise>
          <set-payload value="#[[]]" doc:name="Set Empty Array"/>
        </otherwise>
      </choice>

      <ee:transform doc:name="Transform to Account Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
var accounts = vars.accounts
var owners = payload
var ownersByAccount = owners groupBy $.account_id
---
accounts map ((account) -> {
  id: account.id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: (ownersByAccount[account.id as String] default []) map ((owner) -> {
    customerId: owner.customer_id as String,
    relationshipType: owner.relationship_type
  }),
  createdAt: account.created_at,
  updatedAt: account.updated_at
})]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="200" doc:name="httpStatus" doc:id="d3d4a356-1b30-4ea3-bf48-82e66c597694" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying the database",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="7c320052-c508-4655-9caa-122a076f36ab" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- POST /accounts - Business Logic Flow -->
  <flow name="create-account-business-logic" doc:name="create-account-business-logic">
    <logger level="INFO" message="Creating account with payload: #[payload]" doc:name="Log Request"/>
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeAccountType(at) = 
  if (at == null) null
  else if (at as String == "Checking" or at as String == "checking" or at as String == "CHECKING") "Checking"
  else if (at as String == "Savings" or at as String == "savings" or at as String == "SAVINGS") "Savings"
  else if (at as String == "MoneyMarket" or at as String == "moneymarket" or at as String == "MONEYMARKET") "MoneyMarket"
  else if (at as String == "CertificateOfDeposit" or at as String == "certificateofdeposit" or at as String == "CERTIFICATEOFDEPOSIT") "CertificateOfDeposit"
  else if (at as String == "Other" or at as String == "other" or at as String == "OTHER") "Other"
  else at as String
fun normalizeAccountStatus(s) = 
  if (s == null) "Active"
  else if (s as String == "Active" or s as String == "active" or s as String == "ACTIVE") "Active"
  else if (s as String == "Inactive" or s as String == "inactive" or s as String == "INACTIVE") "Inactive"
  else if (s as String == "Frozen" or s as String == "frozen" or s as String == "FROZEN") "Frozen"
  else if (s as String == "Closed" or s as String == "closed" or s as String == "CLOSED") "Closed"
  else s as String
---
{
  account_number: payload.accountNumber,
  account_type: normalizeAccountType(payload.accountType),
  account_name: payload.accountName default null,
  currency: payload.currency default "USD",
  balance: payload.balance default 0.00,
  available_balance: payload.availableBalance default payload.balance default 0.00,
  status: normalizeAccountStatus(payload.status),
  opened_date: payload.openedDate default null,
  closed_date: payload.closedDate default null,
  interest_rate: payload.interestRate default null
}]]></ee:set-payload>
      </ee:message>
      <ee:variables>
        <ee:set-variable variableName="owners"><![CDATA[%dw 2.0
output application/java
---
payload.owners default []]]></ee:set-variable>
      </ee:variables>
    </ee:transform>

    <set-variable value="#[payload.account_number]" variableName="accountNumber" doc:name="Store Account Number" />

    <try doc:name="Try">
      <db:insert config-ref="Database_Config" doc:name="Insert Account">
        <db:sql><![CDATA[
          INSERT INTO accounts (
            account_number, account_type, account_name, currency,
            balance, available_balance, status, opened_date, closed_date, interest_rate
          )
          VALUES (
            :account_number, :account_type, :account_name, :currency,
            :balance, :available_balance, :status, :opened_date::date, :closed_date::date, :interest_rate
          )
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:insert>

      <db:select config-ref="Database_Config" doc:name="Select Inserted Account">
        <db:sql><![CDATA[
          SELECT *
          FROM accounts
          WHERE account_number = :accountNumber
          ORDER BY created_at DESC
          LIMIT 1
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          accountNumber: vars.accountNumber
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Account Found?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Store Account">
            <ee:variables>
              <ee:set-variable variableName="accountId"><![CDATA[%dw 2.0
output application/java
---
payload[0].id]]></ee:set-variable>
              <ee:set-variable variableName="account"><![CDATA[%dw 2.0
output application/java
---
payload[0]]]></ee:set-variable>
            </ee:variables>
          </ee:transform>
        </when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "ACCOUNT_NOT_FOUND",
    message: "Account was not created or could not be retrieved",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" variableName="httpStatus"/>
        </otherwise>
      </choice>

      <choice doc:name="Has Owners?">
        <when expression="#[sizeOf(vars.owners) > 0]">
          <ee:transform doc:name="Transform Owners for Insert">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeRelationshipType(rt) = 
  if (rt == null) "Primary"
  else if (rt as String == "Primary" or rt as String == "primary" or rt as String == "PRIMARY") "Primary"
  else if (rt as String == "Joint" or rt as String == "joint" or rt as String == "JOINT") "Joint"
  else if (rt as String == "Beneficiary" or rt as String == "beneficiary" or rt as String == "BENEFICIARY") "Beneficiary"
  else rt as String
---
vars.owners map ((owner) -> {
  account_id: vars.accountId,
  customer_id: owner.customerId,
  relationship_type: normalizeRelationshipType(owner.relationshipType)
})]]></ee:set-payload>
            </ee:message>
          </ee:transform>

          <foreach doc:name="Insert Owners">
            <db:insert config-ref="Database_Config" doc:name="Insert Owner">
              <db:sql><![CDATA[
                INSERT INTO account_owners (
                  account_id, customer_id, relationship_type
                )
                VALUES (
                  :account_id::uuid, :customer_id::uuid, :relationship_type
                )
                ON CONFLICT (account_id, customer_id) DO UPDATE SET
                  relationship_type = EXCLUDED.relationship_type
              ]]></db:sql>
              <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
            </db:insert>
          </foreach>
        </when>
      </choice>

      <choice doc:name="Has Account ID?">
        <when expression="#[vars.accountId != null]">
          <db:select config-ref="Database_Config" doc:name="Get Account and Owners">
            <db:sql><![CDATA[
              SELECT
                a.id, a.account_number, a.account_type, a.account_name,
                a.currency, a.balance, a.available_balance, a.status, a.opened_date,
                a.closed_date, a.interest_rate, a.created_at, a.updated_at,
                COALESCE(
                  json_agg(json_build_object('customer_id', ao.customer_id, 'relationship_type', ao.relationship_type)) 
                  FILTER (WHERE ao.customer_id IS NOT NULL),
                  '[]'::json
                ) AS owners
              FROM accounts a
              LEFT JOIN account_owners ao ON a.id = ao.account_id
              WHERE a.id = :accountId::uuid
              GROUP BY a.id, a.account_number, a.account_type, a.account_name,
                a.currency, a.balance, a.available_balance, a.status, a.opened_date,
                a.closed_date, a.interest_rate, a.created_at, a.updated_at
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{
              accountId: vars.accountId
            }]]]></db:input-parameters>
          </db:select>

          <choice doc:name="Account Retrieved?">
            <when expression="#[sizeOf(payload) > 0]">
              <ee:transform doc:name="Transform Response">
                <ee:message>
                  <ee:set-payload><![CDATA[%dw 2.0
output application/json
var result = payload[0] default {}
var account = result default {}
var ownersRaw = result.owners default null
var owners = if (ownersRaw == null) 
   []
  else if (ownersRaw is Array) 
     ownersRaw 
  else []
---
{
  id: account.id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: owners map ((owner) -> {
    customerId: owner.customer_id as String,
    relationshipType: owner.relationship_type
  }) default [],
  createdAt: account.created_at,
  updatedAt: account.updated_at
}]]></ee:set-payload>
                </ee:message>
              </ee:transform>
              <set-variable value="201" doc:name="Set HTTP Status 201" variableName="httpStatus"/>
            </when>
            <otherwise>
              <ee:transform doc:name="Error Response">
                <ee:message>
                  <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "ACCOUNT_NOT_FOUND",
    message: "Account could not be retrieved after creation",
    timestamp: now()
  }
}]]></ee:set-payload>
                </ee:message>
              </ee:transform>
              <set-variable value="500" doc:name="httpStatus" variableName="httpStatus"/>
            </otherwise>
          </choice>
        </when>
        <otherwise>
          <ee:transform doc:name="Error Response - No Account ID">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "ACCOUNT_CREATION_FAILED",
    message: "Account ID was not set after creation",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" variableName="httpStatus"/>
        </otherwise>
      </choice>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while creating the account",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="2ffef3d2-8694-49db-bfe4-8f8be52a19b8" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /accounts/{accountId} - Business Logic Flow -->
  <flow name="get-account-by-id-business-logic" doc:name="get-account-by-id-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Account by ID">
        <db:sql><![CDATA[
          SELECT *
          FROM accounts
          WHERE id = :accountId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          accountId: vars.accountId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Account Found?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Store Account">
            <ee:variables>
              <ee:set-variable variableName="account"><![CDATA[%dw 2.0
output application/java
---
payload[0]]]></ee:set-variable>
            </ee:variables>
          </ee:transform>

          <db:select config-ref="Database_Config" doc:name="Get Owners">
            <db:sql><![CDATA[
              SELECT customer_id, relationship_type
              FROM account_owners
              WHERE account_id = :accountId::uuid
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{
              accountId: vars.accountId
            }]]]></db:input-parameters>
          </db:select>

          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var account = vars.account
var owners = payload
---
{
  id: account.id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: owners map ((owner) -> {
    customerId: owner.customer_id as String,
    relationshipType: owner.relationship_type
  }),
  createdAt: account.created_at,
  updatedAt: account.updated_at
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="200" doc:name="httpStatus" doc:id="bebce04d-9da2-4024-bc0d-d593708650b0" variableName="httpStatus"/>
        
</when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Account not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="404" doc:name="httpStatus" doc:id="da2fcef2-c579-4a34-a4a9-ceb3e96e5e92" variableName="httpStatus"/>
        
</otherwise>
      </choice>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying the database",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="d49217d7-4216-4e11-84d6-430c32f4a848" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- PUT /accounts/{accountId} - Business Logic Flow -->
  <flow name="update-account-business-logic" doc:name="update-account-business-logic">
    <logger level="INFO" message="Updating account with accountId: #[vars.accountId] and payload: #[payload]" doc:name="Log Request"/>
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
  accountId: vars.accountId,
  account_number: payload.accountNumber default null,
  account_type: payload.accountType default null,
  account_name: payload.accountName default null,
  currency: payload.currency default null,
  balance: payload.balance default null,
  available_balance: payload.availableBalance default null,
  status: payload.status default null,
  opened_date: payload.openedDate default null,
  closed_date: payload.closedDate default null,
  interest_rate: payload.interestRate default null
}]]></ee:set-payload>
      </ee:message>
      <ee:variables>
        <ee:set-variable variableName="owners"><![CDATA[#[payload.owners default null]]]></ee:set-variable>
      </ee:variables>
    </ee:transform>

    <try doc:name="Try">
      <db:update config-ref="Database_Config" doc:name="Update Account">
        <db:sql><![CDATA[
          UPDATE accounts
          SET
            account_number = COALESCE(:account_number, account_number),
            account_type = COALESCE(:account_type, account_type),
            account_name = COALESCE(:account_name, account_name),
            currency = COALESCE(:currency, currency),
            balance = COALESCE(:balance, balance),
            available_balance = COALESCE(:available_balance, available_balance),
            status = COALESCE(:status, status),
            opened_date = COALESCE(:opened_date::date, opened_date),
            closed_date = COALESCE(:closed_date::date, closed_date),
            interest_rate = COALESCE(:interest_rate, interest_rate),
            updated_at = CURRENT_TIMESTAMP
          WHERE id = :accountId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:update>

      <db:select config-ref="Database_Config" doc:name="Select Updated Account">
        <db:sql><![CDATA[
          SELECT *
          FROM accounts
          WHERE id = :accountId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          accountId: vars.accountId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Update Successful?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Store Account">
            <ee:variables>
              <ee:set-variable variableName="accountId"><![CDATA[#[payload[0].id]]]></ee:set-variable>
              <ee:set-variable variableName="updatedAccount"><![CDATA[%dw 2.0
output application/java
---
payload[0]]]></ee:set-variable>
            </ee:variables>
          </ee:transform>
          
          <choice doc:name="Update Owners?">
            <when expression="#[vars.owners != null]">
              <db:delete config-ref="Database_Config" doc:name="Delete Existing Owners">
                <db:sql><![CDATA[
                  DELETE FROM account_owners
                  WHERE account_id = :accountId::uuid
                ]]></db:sql>
                <db:input-parameters><![CDATA[#[{
                  accountId: vars.accountId
                }]]]></db:input-parameters>
              </db:delete>

              <ee:transform doc:name="Transform Owners for Insert">
                <ee:message>
                  <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeRelationshipType(rt) = 
  if (rt == null) "Primary"
  else if (rt as String == "Primary" or rt as String == "primary" or rt as String == "PRIMARY") "Primary"
  else if (rt as String == "Joint" or rt as String == "joint" or rt as String == "JOINT") "Joint"
  else if (rt as String == "Beneficiary" or rt as String == "beneficiary" or rt as String == "BENEFICIARY") "Beneficiary"
  else rt as String
---
vars.owners map ((owner) -> {
  account_id: vars.accountId,
  customer_id: owner.customerId,
  relationship_type: normalizeRelationshipType(owner.relationshipType)
})]]></ee:set-payload>
                </ee:message>
              </ee:transform>

              <foreach doc:name="Insert Owners">
                <db:insert config-ref="Database_Config" doc:name="Insert Owner">
                  <db:sql><![CDATA[
                    INSERT INTO account_owners (
                      account_id, customer_id, relationship_type
                    )
                    VALUES (
                      :account_id::uuid, :customer_id::uuid, :relationship_type
                    )
                    ON CONFLICT (account_id, customer_id) DO UPDATE SET
                      relationship_type = EXCLUDED.relationship_type
                  ]]></db:sql>
                  <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
                </db:insert>
              </foreach>
            </when>
          </choice>
          
          <db:select config-ref="Database_Config" doc:name="Get Owners">
            <db:sql><![CDATA[
              SELECT customer_id, relationship_type
              FROM account_owners
              WHERE account_id = :accountId::uuid
            ]]></db:sql>
            <db:input-parameters><![CDATA[#[{
              accountId: vars.accountId
            }]]]></db:input-parameters>
          </db:select>
          
          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var account = vars.updatedAccount
var owners = payload
---
{
  id: account.id as String,
  accountNumber: account.account_number,
  accountType: account.account_type,
  accountName: account.account_name,
  currency: account.currency,
  balance: account.balance,
  availableBalance: account.available_balance,
  status: account.status,
  openedDate: account.opened_date,
  closedDate: account.closed_date,
  interestRate: account.interest_rate,
  owners: owners map ((owner) -> {
    customerId: owner.customer_id as String,
    relationshipType: owner.relationship_type
  }),
  createdAt: account.created_at,
  updatedAt: account.updated_at
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="200" doc:name="httpStatus" doc:id="d43d9b80-8880-4c92-8b2e-31b2c0c32430" variableName="httpStatus"/>
        
</when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Account not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="404" doc:name="httpStatus" doc:id="24aa9e69-304d-43c0-a20f-1d86dc580c45" variableName="httpStatus"/>
        
</otherwise>
      </choice>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while updating the account",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="b44605c0-69cd-4ba0-8159-4d6c8c9ec21b" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /accounts/{accountId}/transactions - Business Logic Flow -->
  <flow name="get-account-transactions-business-logic" doc:name="get-account-transactions-business-logic">
    <ee:transform doc:name="Build Query Parameters">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
  accountId: vars.accountId,
  startDate: if (attributes.queryParams.startDate != null and attributes.queryParams.startDate != "") attributes.queryParams.startDate as String else "",
  endDate: if (attributes.queryParams.endDate != null and attributes.queryParams.endDate != "") attributes.queryParams.endDate as String else "",
  transactionType: if (attributes.queryParams.transactionType != null and attributes.queryParams.transactionType != "") attributes.queryParams.transactionType as String else "",
  status: if (attributes.queryParams.status != null and attributes.queryParams.status != "") attributes.queryParams.status as String else "",
  limit: (attributes.queryParams.limit as Number default 100) as String,
  offset: (attributes.queryParams.offset as Number default 0) as String
}]]></ee:set-payload>
      </ee:message>
    </ee:transform>

    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Transactions">
        <db:sql><![CDATA[
          SELECT *
          FROM transactions
          WHERE account_id = CAST(:accountId AS uuid)
            AND CASE WHEN :startDate = '' THEN true ELSE transaction_date >= TO_DATE(:startDate, 'YYYY-MM-DD') END
            AND CASE WHEN :endDate = '' THEN true ELSE transaction_date <= TO_DATE(:endDate, 'YYYY-MM-DD') END
            AND (:transactionType = '' OR transaction_type = :transactionType)
            AND (:status = '' OR status = :status)
          ORDER BY transaction_date DESC
          LIMIT CAST(COALESCE(:limit, '100') AS integer) OFFSET CAST(COALESCE(:offset, '0') AS integer)
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload default {}]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
payload map ((txn) -> {
  id: txn.id as String,
  transactionNumber: txn.transaction_number,
  accountId: txn.account_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountId: if (txn.related_account_id != null) txn.related_account_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
})]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="200" doc:name="httpStatus" doc:id="858a8f8e-5b03-4001-8757-210847286979" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying transactions",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="f58a6275-05e5-4a6f-bca7-803ec8855393" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- POST /accounts/{accountId}/transactions - Business Logic Flow -->
  <flow name="create-transaction-business-logic" doc:name="create-transaction-business-logic">
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
fun normalizeTransactionType(tt) = 
  if (tt == null) null
  else if (tt as String == "Debit" or tt as String == "debit" or tt as String == "DEBIT") "Debit"
  else if (tt as String == "Credit" or tt as String == "credit" or tt as String == "CREDIT") "Credit"
  else if (tt as String == "Transfer" or tt as String == "transfer" or tt as String == "TRANSFER") "Transfer"
  else if (tt as String == "Fee" or tt as String == "fee" or tt as String == "FEE") "Fee"
  else if (tt as String == "Interest" or tt as String == "interest" or tt as String == "INTEREST") "Interest"
  else if (tt as String == "Reversal" or tt as String == "reversal" or tt as String == "REVERSAL") "Reversal"
  else if (tt as String == "Dispute" or tt as String == "dispute" or tt as String == "DISPUTE") "Dispute"
  else tt as String
fun normalizeTransactionStatus(s) = 
  if (s == null) "Posted"
  else if (s as String == "Pending" or s as String == "pending" or s as String == "PENDING") "Pending"
  else if (s as String == "Posted" or s as String == "posted" or s as String == "POSTED") "Posted"
  else if (s as String == "Cleared" or s as String == "cleared" or s as String == "CLEARED") "Cleared"
  else if (s as String == "Reversed" or s as String == "reversed" or s as String == "REVERSED") "Reversed"
  else if (s as String == "Disputed" or s as String == "disputed" or s as String == "DISPUTED") "Disputed"
  else if (s as String == "Resolved" or s as String == "resolved" or s as String == "RESOLVED") "Resolved"
  else s as String
fun normalizeDisputeStatus(ds) = 
  if (ds == null) "None"
  else if (ds as String == "None" or ds as String == "none" or ds as String == "NONE") "None"
  else if (ds as String == "Initiated" or ds as String == "initiated" or ds as String == "INITIATED") "Initiated"
  else if (ds as String == "UnderReview" or ds as String == "underreview" or ds as String == "UNDERREVIEW") "UnderReview"
  else if (ds as String == "Resolved" or ds as String == "resolved" or ds as String == "RESOLVED") "Resolved"
  else if (ds as String == "Rejected" or ds as String == "rejected" or ds as String == "REJECTED") "Rejected"
  else ds as String
---
{
  account_id: vars.accountId,
  transaction_number: payload.transactionNumber,
  transaction_type: normalizeTransactionType(payload.transactionType),
  amount: payload.amount,
  currency: payload.currency default "USD",
  transaction_date: if (payload.transactionDate != null) 
    ((payload.transactionDate as DateTime) as String {format: "yyyy-MM-dd HH:mm:ss.SSS"}) 
    else (now() as String {format: "yyyy-MM-dd HH:mm:ss.SSS"}),
  value_date: if (payload.valueDate != null) 
    ((payload.valueDate as DateTime) as String {format: "yyyy-MM-dd"}) 
    else "",
  description: payload.description default null,
  merchant_name: payload.merchantName default null,
  category: payload.category default null,
  check_number: payload.checkNumber default null,
  reference_number: payload.referenceNumber default null,
  related_account_id: payload.relatedAccountId default null,
  status: normalizeTransactionStatus(payload.status),
  dispute_status: normalizeDisputeStatus(payload.disputeStatus),
  dispute_reason: payload.disputeReason default null
}]]></ee:set-payload>
      </ee:message>
    </ee:transform>

    <set-variable value="#[payload.transaction_number]" variableName="transactionNumber" doc:name="Store Transaction Number" />
    <logger level="INFO" message="Transaction data - transaction_date: #[payload.transaction_date], value_date: '#[payload.value_date]' (type: #[typeOf(payload.value_date)])" doc:name="Log Transaction Data" />

    <try doc:name="Try">
      <db:insert config-ref="Database_Config" doc:name="Insert Transaction">
        <db:sql><![CDATA[
          INSERT INTO transactions (
            transaction_number, account_id, transaction_type, amount, currency,
            transaction_date, value_date, description, merchant_name, category,
            check_number, reference_number, related_account_id, status,
            dispute_status, dispute_reason
          )
          VALUES (
            :transaction_number, :account_id::uuid, :transaction_type, :amount, :currency,
            TO_TIMESTAMP(:transaction_date, 'YYYY-MM-DD HH24:MI:SS.MS'), 
            CASE 
              WHEN :value_date = '' THEN CAST(NULL AS date)
              ELSE TO_DATE(:value_date, 'YYYY-MM-DD')
            END, 
            :description, :merchant_name, :category,
            :check_number, :reference_number, :related_account_id::uuid, :status,
            :dispute_status, :dispute_reason
          )
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:insert>

      <db:select config-ref="Database_Config" doc:name="Select Inserted Transaction">
        <db:sql><![CDATA[
          SELECT *
          FROM transactions
          WHERE transaction_number = :transactionNumber
          ORDER BY created_at DESC
          LIMIT 1
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          transactionNumber: vars.transactionNumber
        }]]]></db:input-parameters>
      </db:select>

      <ee:transform doc:name="Transform Response">
        <ee:message>
          <ee:set-payload><![CDATA[%dw 2.0
output application/json
var txn = payload[0]
---
{
  id: txn.id as String,
  transactionNumber: txn.transaction_number,
  accountId: txn.account_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountId: if (txn.related_account_id != null) txn.related_account_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
}]]></ee:set-payload>
        </ee:message>
      </ee:transform>

      <set-variable value="201" doc:name="httpStatus" doc:id="6e8b6c05-93a8-499d-b0d0-6366ac8befa5" variableName="httpStatus"/>
      
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while creating the transaction",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="b023816d-c818-4a36-8def-c33ce63b0e09" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- GET /transactions/{transactionId} - Business Logic Flow -->
  <flow name="get-transaction-by-id-business-logic" doc:name="get-transaction-by-id-business-logic">
    <try doc:name="Try">
      <db:select config-ref="Database_Config" doc:name="Select Transaction by ID">
        <db:sql><![CDATA[
          SELECT *
          FROM transactions
          WHERE id = :transactionId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          transactionId: vars.transactionId
        }]]]></db:input-parameters>
      </db:select>
      <choice doc:name="Transaction Found?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var txn = payload[0]
---
{
  id: txn.id as String,
  transactionNumber: txn.transaction_number,
  accountId: txn.account_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountId: if (txn.related_account_id != null) txn.related_account_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="200" doc:name="httpStatus" doc:id="cbedaa58-fd37-4937-be8f-e83ac348e2eb" variableName="httpStatus"/>
        
</when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Transaction not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="404" doc:name="httpStatus" doc:id="f9e0d083-b9c9-41b9-a9ef-2179d85864d6" variableName="httpStatus"/>
        
</otherwise>
      </choice>
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while querying the database",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
          <set-variable value="500" doc:name="httpStatus" doc:id="4cfb4f85-12fd-4dcb-ac2e-fe044bebf6f1" variableName="httpStatus"/>
        </on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- PUT /transactions/{transactionId} - Business Logic Flow -->
  <flow name="update-transaction-business-logic" doc:name="update-transaction-business-logic">
    <ee:transform doc:name="Transform Request to DB Format">
      <ee:message>
        <ee:set-payload><![CDATA[%dw 2.0
output application/java
---
{
  transactionId: vars.transactionId,
  transaction_number: payload.transactionNumber default null,
  transaction_type: payload.transactionType default null,
  amount: payload.amount default null,
  currency: payload.currency default null,
  transaction_date: if (payload.transactionDate != null) 
    ((payload.transactionDate as DateTime) as String {format: "yyyy-MM-dd HH:mm:ss.SSS"}) 
    else null,
  value_date: if (payload.valueDate != null) 
    ((payload.valueDate as DateTime) as String {format: "yyyy-MM-dd"}) 
    else "",
  description: payload.description default null,
  merchant_name: payload.merchantName default null,
  category: payload.category default null,
  check_number: payload.checkNumber default null,
  reference_number: payload.referenceNumber default null,
  related_account_id: payload.relatedAccountId default null,
  status: payload.status default null,
  dispute_status: payload.disputeStatus default null,
  dispute_reason: payload.disputeReason default null
}]]></ee:set-payload>
      </ee:message>
    </ee:transform>
    <try doc:name="Try">
      <db:update config-ref="Database_Config" doc:name="Update Transaction">
        <db:sql><![CDATA[
          UPDATE transactions
          SET
            transaction_number = COALESCE(:transaction_number, transaction_number),
            transaction_type = COALESCE(:transaction_type, transaction_type),
            amount = COALESCE(:amount, amount),
            currency = COALESCE(:currency, currency),
            transaction_date = COALESCE(TO_TIMESTAMP(:transaction_date, 'YYYY-MM-DD HH24:MI:SS.MS'), transaction_date),
            value_date = COALESCE(NULLIF(:value_date, '')::date, value_date),
            description = COALESCE(:description, description),
            merchant_name = COALESCE(:merchant_name, merchant_name),
            category = COALESCE(:category, category),
            check_number = COALESCE(:check_number, check_number),
            reference_number = COALESCE(:reference_number, reference_number),
            related_account_id = COALESCE(:related_account_id::uuid, related_account_id),
            status = COALESCE(:status, status),
            dispute_status = COALESCE(:dispute_status, dispute_status),
            dispute_reason = COALESCE(:dispute_reason, dispute_reason),
            updated_at = CURRENT_TIMESTAMP
          WHERE id = :transactionId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[payload]]]></db:input-parameters>
      </db:update>

      <db:select config-ref="Database_Config" doc:name="Select Updated Transaction">
        <db:sql><![CDATA[
          SELECT *
          FROM transactions
          WHERE id = :transactionId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          transactionId: vars.transactionId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Update Successful?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var txn = payload[0]
---
{
  id: txn.id as String,
  transactionNumber: txn.transaction_number,
  accountId: txn.account_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountId: if (txn.related_account_id != null) txn.related_account_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="200" doc:name="httpStatus" doc:id="cd8acdcd-0d03-463c-b045-cc55536304c3" variableName="httpStatus"/>
        
</when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Transaction not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="404" doc:name="httpStatus" doc:id="9e5ab194-b2d0-4d1b-b4e2-8b725947ed3e" variableName="httpStatus"/>
        
</otherwise>
      </choice>
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while updating the transaction",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="500" doc:name="httpStatus" doc:id="d7ba1b8f-3b61-4a9b-b2eb-c89627de2303" variableName="httpStatus"/>
        
</on-error-propagate>
      </error-handler>
    </try>
  </flow>

  <!-- POST /transactions/{transactionId}/dispute - Business Logic Flow -->
  <flow name="create-dispute-business-logic" doc:name="create-dispute-business-logic">
    <try doc:name="Try">
      <db:update config-ref="Database_Config" doc:name="Update Transaction Dispute">
        <db:sql><![CDATA[
          UPDATE transactions
          SET
            dispute_status = 'Initiated',
            dispute_reason = :disputeReason,
            updated_at = CURRENT_TIMESTAMP
          WHERE id = :transactionId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          transactionId: vars.transactionId,
          disputeReason: payload.disputeReason default "Dispute created"
        }]]]></db:input-parameters>
      </db:update>

      <db:select config-ref="Database_Config" doc:name="Select Updated Transaction">
        <db:sql><![CDATA[
          SELECT *
          FROM transactions
          WHERE id = :transactionId::uuid
        ]]></db:sql>
        <db:input-parameters><![CDATA[#[{
          transactionId: vars.transactionId
        }]]]></db:input-parameters>
      </db:select>

      <choice doc:name="Dispute Created?">
        <when expression="#[sizeOf(payload) > 0]">
          <ee:transform doc:name="Transform Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
var txn = payload[0]
---
{
  id: txn.id as String,
  transactionNumber: txn.transaction_number,
  accountId: txn.account_id as String,
  transactionType: txn.transaction_type,
  amount: txn.amount,
  currency: txn.currency,
  transactionDate: txn.transaction_date,
  valueDate: txn.value_date,
  description: txn.description,
  merchantName: txn.merchant_name,
  category: txn.category,
  checkNumber: txn.check_number,
  referenceNumber: txn.reference_number,
  relatedAccountId: if (txn.related_account_id != null) txn.related_account_id as String else null,
  status: txn.status,
  disputeStatus: txn.dispute_status,
  disputeReason: txn.dispute_reason,
  createdAt: txn.created_at,
  updatedAt: txn.updated_at
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="200" doc:name="httpStatus" doc:id="3d4793c0-bfec-4910-be53-12c7b52e7f5c" variableName="httpStatus"/>
        
</when>
        <otherwise>
          <ee:transform doc:name="Error Response">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "NOT_FOUND",
    message: "Transaction not found",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="404" doc:name="httpStatus" doc:id="379cfdca-ff77-4d69-a344-5a1bd22324e9" variableName="httpStatus"/>
        
</otherwise>
      </choice>
      <error-handler>
        <on-error-propagate type="*" enableNotifications="true" logException="true" doc:name="Error Handler">
          <ee:transform doc:name="Transform Error">
            <ee:message>
              <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
  error: {
    code: "DATABASE_ERROR",
    message: "An error occurred while creating the dispute",
    timestamp: now()
  }
}]]></ee:set-payload>
            </ee:message>
          </ee:transform>
					<set-variable value="500" doc:name="httpStatus" doc:id="008d3340-db1b-4333-9f2a-c1b496508cf8" variableName="httpStatus"/>
        
</on-error-propagate>
      </error-handler>
    </try>
  </flow>

</mule>
